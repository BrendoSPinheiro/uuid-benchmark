'use strict'

const fs = require('fs')
const {Suite} = require('benchmark')
const toCsv = require('csv-stringify')
const table = require('markdown-table')
const numeral = require('numeral')

const suite = new Suite()

suite.cacheSizes = [16 ** 2, 16 ** 3, 16 ** 4]

const single = process.argv[2]

if (single) {
  require(single)(suite)
} else {
  // uuid
  require('./benchmarks/uuid')(suite)
  require('./benchmarks/fast-uuid')(suite)
  require('./benchmarks/uuid-random')(suite)
  require('./benchmarks/sodium-uuid')(suite)
  require('./benchmarks/crypto.randomBytes')(suite)
  require('./benchmarks/crypto.randomFillSync')(suite)
  require('./benchmarks/crypto.randomFill')(suite)
  require('./benchmarks/dev-random')(suite)

  // other
  require('./benchmarks/hyperid')(suite)
  require('./benchmarks/cuid')(suite)
  require('./benchmarks/shortid')(suite)
  require('./benchmarks/nanoid')(suite)
}

suite
  .on('cycle', function (event) {
    const t = event.target
    console.log(`${desc(t)} x ${numeral(t.hz).format('0,0')} ops/sec ¬±${t.stats.rme.toFixed(2)}% (${t.stats.sample.length} runs sampled)`)
  })
  .on('complete', function () {
    console.log('Fastest is ' + desc(this.filter('fastest')[0]))

    // if running just a single benchmark, skip updating result files
    if (!single) {
      updateReadme()
      updateCsv()
    }
  })
  .run()

function updateReadme () {
  const path = 'README.md'
  const marker = '<!-- AUTOGENERATED - DO NOT EDIT -->\n'
  const parts = fs.readFileSync(path, 'utf8').split(marker)
  parts[1] = uuidTable()
  parts[3] = otherTable()
  fs.writeFileSync(path, parts.join(marker))
}

function updateCsv () {
  csv(function (err, output) {
    if (err) throw err
    fs.writeFileSync('results.csv', output)
  })
}

function uuidTable () {
  const arr = suite.filter(function (b) {
    return b.format !== 'other'
  }).map(function (b) {
    return [
      `[${b.name}] ${b.postfix || ''}`,
      leaky(b),
      reuse(b),
      sync(b),
      b.cacheSize || '',
      b.format,
      numeral(b.hz).format('0,0'),
      `¬±${b.stats.rme.toFixed(2)}%`,
      b.stats.sample.length
    ]
  })

  arr.unshift([
    'Method',
    'Leaky',
    'Re-use',
    'Sync',
    'Cache',
    'Format',
    'Ops/sec',
    'RME',
    'Samples'
  ])

  return table(arr, {align: ['l', 'c', 'c', 'c', 'r', 'l', 'r', 'l', 'r']}) + '\n'
}

function otherTable () {
  const arr = suite.filter(function (b) {
    return b.format === 'other'
  }).map(function (b) {
    return [
      `[${b.name}] ${b.postfix || ''}`,
      guid(b),
      leaky(b),
      reuse(b),
      sync(b),
      b.cacheSize || '',
      numeral(b.hz).format('0,0'),
      `¬±${b.stats.rme.toFixed(2)}%`,
      b.stats.sample.length,
      `<sub><sub>${b.example}</sub></sub>`
    ]
  })

  arr.unshift([
    'Method',
    'GUID',
    'Leaky',
    'Re-use',
    'Sync',
    'Cache',
    'Ops/sec',
    'RME',
    'Samples',
    'Example'
  ])

  return table(arr, {align: ['l', 'c', 'c', 'c', 'c', 'r', 'r', 'l', 'r', 'l']}) + '\n'
}

function csv (cb) {
  const arr = suite.map(function (b) {
    return [
      fullName(b),
      b.format !== 'other' || b.guid ? 'Y' : 'N',
      b.leaky ? 'Y' : 'N',
      b.reuse ? 'Y' : 'N',
      !b.defer ? 'Y' : 'N',
      b.cacheSize || '',
      b.format,
      b.hz,
      b.stats.deviation,
      b.stats.mean,
      b.stats.moe,
      b.stats.rme,
      b.stats.sample.length,
      b.stats.sem,
      b.stats.variance
    ]
  })

  arr.unshift([
    'Method',
    'GUID',
    'Leaky',
    'Re-use',
    'Sync',
    'Cache',
    'Format',
    'Ops/sec',
    'Deviation',
    'Mean',
    'MOE',
    'RME',
    'Samples',
    'SEM',
    'Variance'
  ])

  toCsv(arr, cb)
}

function fullName (b) {
  return b.name + (b.postfix ? ' ' + b.postfix : '')
}

function desc (b) {
  return `${fullName(b)} (format: ${b.format}, re-use: ${!!b.reuse}, cache: ${b.cacheSize || 'n/a'}, sync: ${!b.defer})`
}

function guid (b) {
  return b.format !== 'other' || b.guid ? 'üåé' : ''
}

function leaky (b) {
  return b.leaky ? 'üí¶' : ''
}

function reuse (b) {
  return b.reuse ? '‚ôªÔ∏è' : ''
}

function sync (b) {
  return !b.defer ? '‚¨áÔ∏è' : ''
}
